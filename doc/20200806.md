# On excessive subsequent calls and the stack

I've been reluctant to depend too much on function calls. When parsing really large and complex source code, you'll probably get into really deep sequences of subsequent calls just to follow the structure that present in the code that you'll risk to hit a stack overflow. With the cheapness and plentitude of memory of the present day, even if there's really complex code that would hit a stack overflow, changes are you'll get success by increasing the memory reserved for the stack. (Or also that you'll be better of splitting that large chunk of logic into smaller source-files that combine into equivalent structure.) Perhaps it's a left-over from my 16-bits days.

One thing I would do is keep track of 'recurrences' in an array myself, and use a loop to process the code until this stack runs out. Or if there's more to store on the stack, use `SetLength` to just extent the size of the array. Having your sequence there in a structure you control, has some advantages when debugging for example, but has the disadvantage that your code may get more complex. Where you would write a normal function call, you need to push to the alternative stack and set up code elsewhere to run when a pop reaches this same position on the stack.

One way perhaps to handle this is write the logic in some other code, but that is absurd since we're already writing exactly a new processer for this new code that is a new programming language. I've heard whispers that it's something like that that's Perl 6 built up around, but I don't now anything about Perl, really.

So, recently, I thought what about a linked list. Instead of pre-allocating a stack that can grow and shrink as needed, a link list just has nodes and you allocate each noe there and then when you need it.
xxxx